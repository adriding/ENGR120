#pragma config(Sensor, in1,    InfraCollector1, sensorReflection)
#pragma config(Sensor, in2,    InfraCollector2, sensorReflection)
#pragma config(Sensor, dgtl2,  switch1,        sensorTouch)
#pragma config(Sensor, dgtl4,  button1,        sensorTouch)
#pragma config(Sensor, dgtl5,  Sonar,          sensorSONAR_mm)
#pragma config(Sensor, dgtl7,  RedLED1,        sensorDigitalOut)
#pragma config(Sensor, dgtl8,  RedLED2,        sensorDigitalOut)
#pragma config(Sensor, dgtl12, switch2,        sensorTouch)
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           motor3,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          motor2,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool button1_pushed;
bool switch1_pushed;
bool switch2_pushed;
// Threshold of value read from phototransistor circuit.
const   int IR_SENSOR_THRESHOLD = 300;
const   int IR_SENSOR_THRESHOLD2 = 3800;//some number when the robot is in the range of one meter;

int threshold_sonar = 110;
//int threshold_sonar2 = 130;

const int OFF = 0;
const int ON  = 1;

void monitorInput(){
	if(SensorValue(button1)){
		button1_pushed = true;
	}
	if(SensorValue(switch1))
	{
		switch1_pushed = true;
	}
	if(SensorValue(switch2))
	{
		switch2_pushed = true;
	}
}

void init_light_status()
{
  // Turn of the red LED
  SensorValue(RedLED1)= OFF;
  SensorValue(RedLED2)= OFF;
}


task main(){

  init_light_status();

 while (true){

  	int state = 1;

		switch(state){
      // Management of system when in state 0
    	case 1:
    	  monitorInput();
				if( button1_pushed ){//turn itself
				button1_pushed = false;
				motor(port1) = 35;
				motor(port10) = 35;
        state = 2;
				}

    	case 2:
    		while((SensorValue[InfraCollector1] >= IR_SENSOR_THRESHOLD) && (SensorValue[InfraCollector2] >= IR_SENSOR_THRESHOLD) && (SensorValue[InfraCollector1] < IR_SENSOR_THRESHOLD2) && (SensorValue[InfraCollector2] < IR_SENSOR_THRESHOLD2)){
    			while(SensorValue(Sonar) > threshold_sonar){
		      	SensorValue(RedLED1) = 1;//if the source is too far away, and the difference between two sensors is larger than 10, the LED1 lighting up
						SensorValue(RedLED2) = 0;
		        if((SensorValue[InfraCollector1] - SensorValue[InfraCollector2]) >= 100 && (SensorValue[InfraCollector1] - SensorValue[InfraCollector2]) <= 500){
			        SensorValue(RedLED1)= ON;
		        	motor(port1) = -30;//if the sensor1 - sensor2 is greater than 10, turn right
							motor(port10) = -30;
			      }
			      else if((SensorValue[InfraCollector2] - SensorValue[InfraCollector1]) >= 100 && (SensorValue[InfraCollector1] - SensorValue[InfraCollector2]) <= 500){
			      	SensorValue(RedLED1)= ON;
			      	motor(port1) = 30;//if the sensor2 - sensor1 is greater than 10, turn left
							motor(port10) = 30;
			      }
			      else{
			      	motor(port1) = -30;//if the sensor2 - sensor1 is greater than 10, turn left
							motor(port10) = 30;
					  }
					  }
							if(SensorValue(Sonar) <= threshold_sonar /*&& SensorValue(Sonar) >= threshold_sonar2*/){
		    			//SensorValue(RedLED2)= ON;
			    		motor(port1) = 0;
							motor(port10) = 0;
							SensorValue(RedLED1) = 0;
							SensorValue(RedLED2) = 1;//if the source is close enough, and the difference between two sensors is within 10, the LED2 lighting up
							clearTimer(T4);
								while(time1[T4] < 700){
									motor[motor3] = -100;
						 		}
							motor[motor3] = 0;
							state = 3;
			  		}//end of while loop

			}


		case 3:
		while(state == 3){
					motor[motor1] = 50;//go backward
					motor[motor2] = -50;
						monitorInput();

							if(switch1_pushed && switch2_pushed){
								monitorInput();
								switch1_pushed = false;
								switch2_pushed = false;
								motor[motor1] = 0;
								motor[motor2] = 0;
								clearTimer(T3);
								while(time1[T3] < 1000 ){
									motor[motor3] = -100;
								}
								motor[motor3] = 0;
								motor[motor1] = 0;
								motor[motor2] = 0;
								break;
							}

						if(switch1_pushed){
							monitorInput();
							switch1_pushed = false;
							clearTimer(T1);
							while(time1[T1] < 800){
							motor[motor1] = -30;
					  	motor[motor2] = -30;}
					  	clearTimer(T1);
							while(time1[T1] < 800){
							motor[motor1] = 30;
					  	motor[motor2] = -30;}
						}

							if(switch2_pushed){
							monitorInput();
							switch2_pushed = false;
							clearTimer(T1);
							while(time1[T1] < 800){
							motor[motor1] = 30;
					  	motor[motor2] = 30;}
					  	clearTimer(T1);
							while(time1[T1] < 800){
							motor[motor1] = 30;
					  	motor[motor2] = -30;}
						}
					}

    	default: // We should never be in this state.
    } // switch(state)
  } // while(true)
}
